name: SDK Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  schedule:
    # Run tests daily at 2 AM UTC to catch any API changes
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  test-sdk:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
        webrtc-lib: ['@roamhq/wrtc', 'node-datachannel']
    
    name: Node ${{ matrix.node-version }} - ${{ matrix.webrtc-lib }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    
    - name: Install dependencies
      run: |
        npm install
        npm install ${{ matrix.webrtc-lib }}
    
    - name: Run basic connectivity test
      run: |
        cat > test-connectivity.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        
        async function test() {
            const vdo = new VDONinjaSDK();
            try {
                await vdo.connect();
                console.log('✅ Connected to signaling server');
                
                const roomId = 'ci-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
                await vdo.joinRoom({ room: roomId });
                console.log('✅ Joined room');
                
                await vdo.announce({ streamID: "stream-" + Math.random().toString(36).substr(2, 9) });
                console.log('✅ Announced stream');
                
                vdo.disconnect();
                console.log('✅ Disconnected cleanly');
                process.exit(0);
            } catch (error) {
                console.error('❌ Test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-connectivity.js
    
    - name: Run P2P data channel test
      run: |
        cat > test-p2p-datachannel.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        
        const TEST_ROOM = 'ci-p2p-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PUBLISHER_STREAM = 'pub-' + Math.random().toString(36).substr(2, 9);
        let messageReceived = false;
        
        async function createPublisher() {
            const publisher = new VDONinjaSDK();
            
            publisher.addEventListener('peerConnected', async (event) => {
                console.log('[Publisher] Peer connected');
                setTimeout(() => {
                    publisher.sendData({ test: 'message', timestamp: Date.now() });
                    console.log('[Publisher] Sent test message');
                }, 1000);
            });
            
            await publisher.connect();
            await publisher.joinRoom({ room: TEST_ROOM });
            await publisher.announce({ streamID: PUBLISHER_STREAM });
            console.log('[Publisher] Ready');
            return publisher;
        }
        
        async function createViewer() {
            const viewer = new VDONinjaSDK();
            
            viewer.addEventListener('dataReceived', (event) => {
                console.log('[Viewer] Received:', event.detail.data);
                messageReceived = true;
            });
            
            await viewer.connect();
            await viewer.joinRoom({ room: TEST_ROOM });
            await viewer.view(PUBLISHER_STREAM);
            console.log('[Viewer] Connected to publisher');
            return viewer;
        }
        
        async function test() {
            try {
                const publisher = await createPublisher();
                await new Promise(r => setTimeout(r, 1000));
                const viewer = await createViewer();
                
                // Wait for message exchange
                await new Promise(r => setTimeout(r, 5000));
                
                if (messageReceived) {
                    console.log('✅ P2P data channel test passed');
                    publisher.disconnect();
                    viewer.disconnect();
                    process.exit(0);
                } else {
                    throw new Error('No message received');
                }
            } catch (error) {
                console.error('❌ P2P test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-p2p-datachannel.js
    
    - name: Run bidirectional communication test
      run: |
        cat > test-bidirectional.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        
        const TEST_ROOM = 'ci-bidir-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PUB_STREAM = 'pub-' + Math.random().toString(36).substr(2, 9);
        let pubRecv = false, viewRecv = false;
        
        async function test() {
            try {
                const publisher = new VDONinjaSDK();
                const viewer = new VDONinjaSDK();
                
                publisher.addEventListener('dataReceived', (e) => {
                    console.log('[Publisher] Received:', e.detail.data);
                    pubRecv = true;
                });
                
                viewer.addEventListener('dataReceived', (e) => {
                    console.log('[Viewer] Received:', e.detail.data);
                    viewRecv = true;
                });
                
                await publisher.connect();
                await publisher.joinRoom({ room: TEST_ROOM });
                await publisher.announce({ streamID: PUB_STREAM });
                
                await viewer.connect();
                await viewer.joinRoom({ room: TEST_ROOM });
                await viewer.view(PUB_STREAM);
                
                await new Promise(r => setTimeout(r, 2000));
                
                // Test bidirectional
                publisher.sendData({ from: 'publisher', test: 1 });
                viewer.sendData({ from: 'viewer', test: 2 });
                
                await new Promise(r => setTimeout(r, 3000));
                
                if (pubRecv && viewRecv) {
                    console.log('✅ Bidirectional communication works');
                    publisher.disconnect();
                    viewer.disconnect();
                    process.exit(0);
                } else {
                    throw new Error(`Bidirectional failed: pub=${pubRecv}, view=${viewRecv}`);
                }
            } catch (error) {
                console.error('❌ Bidirectional test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-bidirectional.js
    
    - name: Run duplicate prevention test
      if: matrix.webrtc-lib == '@roamhq/wrtc'
      run: |
        cat > test-no-duplicates.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        
        const TEST_ROOM = 'ci-dup-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PEER1_STREAM = 'p1-' + Math.random().toString(36).substr(2, 9);
        const PEER2_STREAM = 'p2-' + Math.random().toString(36).substr(2, 9);
        let messagesReceived = [];
        
        async function test() {
            try {
                const peer1 = new VDONinjaSDK();
                const peer2 = new VDONinjaSDK();
                
                peer2.addEventListener('dataReceived', (e) => {
                    console.log('[Peer2] Received:', e.detail.data);
                    messagesReceived.push(e.detail.data);
                });
                
                // Both announce and view each other (dual connection)
                await peer1.connect();
                await peer1.joinRoom({ room: TEST_ROOM });
                await peer1.announce({ streamID: PEER1_STREAM });
                
                await peer2.connect();
                await peer2.joinRoom({ room: TEST_ROOM });
                await peer2.announce({ streamID: PEER2_STREAM });
                
                await new Promise(r => setTimeout(r, 1000));
                
                await peer1.view(PEER2_STREAM);
                await peer2.view(PEER1_STREAM);
                
                await new Promise(r => setTimeout(r, 3000));
                
                // Send message (should only receive once despite dual connection)
                peer1.sendData({ test: 'no-duplicate', id: 1 });
                
                await new Promise(r => setTimeout(r, 2000));
                
                if (messagesReceived.length === 1) {
                    console.log('✅ No duplicates with dual connections');
                    peer1.disconnect();
                    peer2.disconnect();
                    process.exit(0);
                } else {
                    throw new Error(`Expected 1 message, got ${messagesReceived.length}`);
                }
            } catch (error) {
                console.error('❌ Duplicate prevention test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-no-duplicates.js
    
    - name: Run alias compatibility test
      run: |
        cat > test-aliases.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        
        async function test() {
            try {
                const vdo = new VDONinjaSDK();
                
                // Test aliases exist
                const aliases = ['send', 'sendMessage', 'emit', 'broadcast'];
                for (const alias of aliases) {
                    if (typeof vdo[alias] !== 'function') {
                        throw new Error(`Alias ${alias} not found`);
                    }
                }
                
                console.log('✅ All aliases exist');
                process.exit(0);
            } catch (error) {
                console.error('❌ Alias test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-aliases.js

  test-summary:
    needs: test-sdk
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Check test results
      run: |
        if [ "${{ needs.test-sdk.result }}" == "success" ]; then
          echo "✅ All SDK tests passed!"
          exit 0
        else
          echo "❌ Some SDK tests failed"
          exit 1
        fi