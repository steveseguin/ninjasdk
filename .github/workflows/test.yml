name: SDK Tests

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  schedule:
    # Run tests daily at 2 AM UTC to catch any API changes
    - cron: '0 2 * * *'
  workflow_dispatch:

jobs:
  test-sdk:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
        webrtc-lib: ['@roamhq/wrtc', 'node-datachannel']
    
    name: Node ${{ matrix.node-version }} - ${{ matrix.webrtc-lib }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
    
    - name: Install dependencies
      run: |
        npm install
        npm install ${{ matrix.webrtc-lib }}
    
    - name: Run basic connectivity test
      run: |
        cat > test-connectivity.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const WebSocket = require('ws');
        const crypto = require('crypto');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        // Polyfills for Node.js
        global.WebSocket = WebSocket;
        global.crypto = crypto.webcrypto || crypto;
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        global.CustomEvent = class CustomEvent extends Event {
            constructor(type, options) {
                super(type, options);
                this.detail = options?.detail;
            }
        };
        global.btoa = (str) => Buffer.from(str).toString('base64');
        global.atob = (str) => Buffer.from(str, 'base64').toString();
        
        const WSS = process.env.WSS_URL || 'wss://apibackup.vdo.ninja';

        async function test() {
            const vdo = new VDONinjaSDK({ host: WSS });
            try {
                await vdo.connect();
                console.log('✅ Connected to signaling server');
                
                const roomId = 'ci-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
                await vdo.joinRoom({ room: roomId });
                console.log('✅ Joined room');
                
                await vdo.announce({ streamID: "stream-" + Math.random().toString(36).substr(2, 9) });
                console.log('✅ Announced stream');
                
                vdo.disconnect();
                console.log('✅ Disconnected cleanly');
                process.exit(0);
            } catch (error) {
                console.error('❌ Test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-connectivity.js
    
    - name: Run P2P data channel test
      run: |
        cat > test-p2p-datachannel.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const WebSocket = require('ws');
        const crypto = require('crypto');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        // Polyfills for Node.js
        global.WebSocket = WebSocket;
        global.crypto = crypto.webcrypto || crypto;
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        global.CustomEvent = class CustomEvent extends Event {
            constructor(type, options) {
                super(type, options);
                this.detail = options?.detail;
            }
        };
        global.btoa = (str) => Buffer.from(str).toString('base64');
        global.atob = (str) => Buffer.from(str, 'base64').toString();
        
        const WSS = process.env.WSS_URL || 'wss://apibackup.vdo.ninja';
        const TEST_ROOM = 'ci-p2p-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PUBLISHER_STREAM = 'pub-' + Math.random().toString(36).substr(2, 9);
        let messageReceived = false;
        
        async function createPublisher() {
            const publisher = new VDONinjaSDK({ host: WSS });
            
            publisher.addEventListener('peerConnected', async (event) => {
                console.log('[Publisher] Peer connected');
                setTimeout(() => {
                    publisher.sendData({ test: 'message', timestamp: Date.now() });
                    console.log('[Publisher] Sent test message');
                }, 1000);
            });
            
            await publisher.connect();
            await publisher.joinRoom({ room: TEST_ROOM });
            await publisher.announce({ streamID: PUBLISHER_STREAM });
            console.log('[Publisher] Ready');
            return publisher;
        }
        
        async function createViewer() {
            const viewer = new VDONinjaSDK({ host: WSS });
            
            viewer.addEventListener('dataReceived', (event) => {
                console.log('[Viewer] Received:', event.detail.data);
                messageReceived = true;
            });
            
            await viewer.connect();
            await viewer.joinRoom({ room: TEST_ROOM });
            await viewer.view(PUBLISHER_STREAM);
            console.log('[Viewer] Connected to publisher');
            return viewer;
        }
        
        async function test() {
            try {
                const publisher = await createPublisher();
                await new Promise(r => setTimeout(r, 1000));
                const viewer = await createViewer();
                
                // Wait for message exchange
                await new Promise(r => setTimeout(r, 5000));
                
                if (messageReceived) {
                    console.log('✅ P2P data channel test passed');
                    publisher.disconnect();
                    viewer.disconnect();
                    process.exit(0);
                } else {
                    throw new Error('No message received');
                }
            } catch (error) {
                console.error('❌ P2P test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-p2p-datachannel.js
    
    - name: Run bidirectional communication test
      run: |
        cat > test-bidirectional.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const WebSocket = require('ws');
        const crypto = require('crypto');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        // Polyfills for Node.js
        global.WebSocket = WebSocket;
        global.crypto = crypto.webcrypto || crypto;
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        global.CustomEvent = class CustomEvent extends Event {
            constructor(type, options) {
                super(type, options);
                this.detail = options?.detail;
            }
        };
        global.btoa = (str) => Buffer.from(str).toString('base64');
        global.atob = (str) => Buffer.from(str, 'base64').toString();
        
        const WSS = process.env.WSS_URL || 'wss://apibackup.vdo.ninja';
        const TEST_ROOM = 'ci-bidir-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PUB_STREAM = 'pub-' + Math.random().toString(36).substr(2, 9);
        let pubRecv = false, viewRecv = false;
        
        async function test() {
            try {
                const publisher = new VDONinjaSDK({ host: WSS });
                const viewer = new VDONinjaSDK({ host: WSS });
                
                publisher.addEventListener('dataReceived', (e) => {
                    console.log('[Publisher] Received:', e.detail.data);
                    pubRecv = true;
                });
                
                viewer.addEventListener('dataReceived', (e) => {
                    console.log('[Viewer] Received:', e.detail.data);
                    viewRecv = true;
                });
                
                await publisher.connect();
                await publisher.joinRoom({ room: TEST_ROOM });
                await publisher.announce({ streamID: PUB_STREAM });
                
                await viewer.connect();
                await viewer.joinRoom({ room: TEST_ROOM });
                await viewer.view(PUB_STREAM);
                
                await new Promise(r => setTimeout(r, 5000));
                
                // Test bidirectional
                publisher.sendData({ from: 'publisher', test: 1 });
                viewer.sendData({ from: 'viewer', test: 2 });
                
                await new Promise(r => setTimeout(r, 3000));
                
                if (pubRecv && viewRecv) {
                    console.log('✅ Bidirectional communication works');
                    publisher.disconnect();
                    viewer.disconnect();
                    process.exit(0);
                } else {
                    throw new Error(`Bidirectional failed: pub=${pubRecv}, view=${viewRecv}`);
                }
            } catch (error) {
                console.error('❌ Bidirectional test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-bidirectional.js
    
    - name: Run duplicate prevention test
      if: matrix.webrtc-lib == '@roamhq/wrtc'
      run: |
        cat > test-no-duplicates.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const WebSocket = require('ws');
        const crypto = require('crypto');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        // Polyfills for Node.js
        global.WebSocket = WebSocket;
        global.crypto = crypto.webcrypto || crypto;
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        global.CustomEvent = class CustomEvent extends Event {
            constructor(type, options) {
                super(type, options);
                this.detail = options?.detail;
            }
        };
        global.btoa = (str) => Buffer.from(str).toString('base64');
        global.atob = (str) => Buffer.from(str, 'base64').toString();
        
        const WSS = process.env.WSS_URL || 'wss://apibackup.vdo.ninja';
        const TEST_ROOM = 'ci-dup-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
        const PEER1_STREAM = 'p1-' + Math.random().toString(36).substr(2, 9);
        const PEER2_STREAM = 'p2-' + Math.random().toString(36).substr(2, 9);
        let messagesReceived = [];
        let PEER2_UUID = null;
        const DP_DEBUG = !!process.env.DP_DEBUG && process.env.DP_DEBUG !== '0';
        const dp = (...args) => { if (DP_DEBUG) console.log(...args); };

        function logConnections(sdk, label) {
          try {
            const list = [];
            for (const [uuid, conns] of sdk.connections || []) {
              for (const t of ['publisher','viewer']) {
                const c = conns[t];
                if (c) list.push({ uuid: c.uuid, type: c.type, streamID: c.streamID, dc: c.dataChannel?.readyState, ice: c.pc?.iceConnectionState });
              }
            }
            dp('[DP]', label, 'connections:', list);
          } catch (e) {}
        }

        async function test() {
            try {
                const peer1 = new VDONinjaSDK({ host: WSS });
                const peer2 = new VDONinjaSDK({ host: WSS });
                dp('[DP] WSS:', WSS);
                dp('[DP] ROOM:', TEST_ROOM, 'P1:', PEER1_STREAM, 'P2:', PEER2_STREAM);

                // Capture peer2's UUID from peer1's perspective
                peer1.addEventListener('peerConnected', (e) => {
                  dp('[DP] peer1 peerConnected:', e.detail?.uuid, e.detail?.connection?.type);
                  if (!PEER2_UUID && e?.detail?.uuid) { PEER2_UUID = e.detail.uuid; }
                });
                peer2.addEventListener('peerConnected', (e) => {
                  dp('[DP] peer2 peerConnected:', e.detail?.uuid, e.detail?.connection?.type);
                });

                for (const sdk of [peer1, peer2]) {
                  sdk.addEventListener('dataChannelOpen', (e) => dp('[DP] dataChannelOpen', sdk===peer1?'peer1':'peer2', e.detail));
                  sdk.addEventListener('listing', (e) => dp('[DP] listing', sdk===peer1?'peer1':'peer2', e.detail?.streamID || '(list)'));
                  sdk.addEventListener('videoaddedtoroom', (e) => dp('[DP] videoadded', sdk===peer1?'peer1':'peer2', e.detail.streamID, e.detail.uuid));
                  sdk.addEventListener('streamAdded', (e) => dp('[DP] streamAdded', sdk===peer1?'peer1':'peer2', e.detail.streamID, e.detail.uuid));
                  sdk.addEventListener('error', (e) => dp('[DP] error', sdk===peer1?'peer1':'peer2', e.detail));
                  sdk.addEventListener('alert', (e) => dp('[DP] alert', sdk===peer1?'peer1':'peer2', e.detail));
                }

                peer2.addEventListener('dataReceived', (e) => {
                    const d = e.detail?.data;
                    if (d && d.test === 'no-duplicate' && d.id === 1) {
                        console.log('[Peer2] Received (counted):', d);
                        messagesReceived.push(d);
                    } else {
                        console.log('[Peer2] Received (ignored):', d);
                    }
                });
                
                // Both announce and view each other (dual connection)
                dp('[DP] peer1.connect');
                await peer1.connect();
                dp('[DP] peer1.joinRoom');
                await peer1.joinRoom({ room: TEST_ROOM });
                dp('[DP] peer1.announce');
                await peer1.announce({ streamID: PEER1_STREAM });
                
                dp('[DP] peer2.connect');
                await peer2.connect();
                dp('[DP] peer2.joinRoom');
                await peer2.joinRoom({ room: TEST_ROOM });
                dp('[DP] peer2.announce');
                await peer2.announce({ streamID: PEER2_STREAM });
                logConnections(peer1, 'after announce peer1');
                logConnections(peer2, 'after announce peer2');
                
                await new Promise(r => setTimeout(r, 1000));
                
                dp('[DP] peer1.view(PEER2_STREAM)');
                await peer1.view(PEER2_STREAM);
                dp('[DP] peer2.view(PEER1_STREAM)');
                await peer2.view(PEER1_STREAM);
                
                // Helper: wait until a data channel is open between peers
                async function waitForOpenDC(sdk, uuid, timeoutMs = 15000) {
                  const start = Date.now();
                  return new Promise((resolve) => {
                    const check = () => {
                      try {
                        for (const [id, conns] of sdk.connections || []) {
                          if (uuid && id !== uuid) continue;
                          for (const t of ['publisher','viewer']) {
                            const c = conns[t];
                            if (c && c.dataChannel && c.dataChannel.readyState === 'open') {
                              return resolve(true);
                            }
                          }
                        }
                      } catch (e) {}
                      if (Date.now() - start >= timeoutMs) return resolve(false);
                      setTimeout(check, 200);
                    };
                    const onOpen = (e) => {
                      if (!uuid || e.detail?.uuid === uuid) {
                        resolve(true);
                      }
                    };
                    try { sdk.addEventListener('dataChannelOpen', onOpen); } catch (e) {}
                    check();
                  });
                }

                // If we know peer2's UUID, wait for DC to open before sending (more reliable on Node 18)
                if (PEER2_UUID) {
                  const ok = await waitForOpenDC(peer1, PEER2_UUID, 15000);
                  dp('[DP] waitForOpenDC result:', ok);
                }

                // Retry sending until the SDK confirms sent (up to 20s)
                const payload = { test: 'no-duplicate', id: 1 };
                let sent = false;
                let attempts = 0;
                const deadline = Date.now() + 20000;
                while (!sent && Date.now() < deadline) {
                  attempts++;
                  if (PEER2_UUID) {
                    sent = peer1.sendData(payload, PEER2_UUID);
                    dp('[DP] send attempt', attempts, '(uuid)', PEER2_UUID, 'sent=', sent);
                  } else {
                    sent = peer1.sendData(payload, { streamID: PEER2_STREAM, type: 'viewer' });
                    dp('[DP] send attempt', attempts, '(streamID viewer)', PEER2_STREAM, 'sent=', sent);
                  }
                  if (!sent) {
                    logConnections(peer1, 'peer1 pre-wait');
                    logConnections(peer2, 'peer2 pre-wait');
                    await new Promise(r => setTimeout(r, 300));
                  }
                }
                dp('[DP] after send attempts, sent=', sent);
                if (!sent) {
                  dp('[DP] state: p1.connected=', peer1.state.connected, 'p2.connected=', peer2.state.connected);
                  throw new Error('Failed to send test message after retries');
                }
                
                await new Promise(r => setTimeout(r, 5000));
                
                if (messagesReceived.length === 1) {
                    console.log('✅ No duplicates with dual connections');
                    peer1.disconnect();
                    peer2.disconnect();
                    process.exit(0);
                } else {
                    throw new Error(`Expected 1 message, got ${messagesReceived.length}`);
                }
            } catch (error) {
                console.error('❌ Duplicate prevention test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 45s node test-no-duplicates.js
    
    - name: Run alias compatibility test
      run: |
        cat > test-aliases.js << 'EOF'
        const wrtc = require('@roamhq/wrtc');
        const WebSocket = require('ws');
        const crypto = require('crypto');
        const VDONinjaSDK = require('./vdoninja-sdk.js');
        
        // Polyfills for Node.js
        global.WebSocket = WebSocket;
        global.crypto = crypto.webcrypto || crypto;
        global.RTCPeerConnection = wrtc.RTCPeerConnection;
        global.RTCIceCandidate = wrtc.RTCIceCandidate;
        global.RTCSessionDescription = wrtc.RTCSessionDescription;
        global.document = { createElement: () => ({ innerText: '', textContent: '' }) };
        global.CustomEvent = class CustomEvent extends Event {
            constructor(type, options) {
                super(type, options);
                this.detail = options?.detail;
            }
        };
        global.btoa = (str) => Buffer.from(str).toString('base64');
        global.atob = (str) => Buffer.from(str, 'base64').toString();
        
        async function test() {
            try {
                const vdo = new VDONinjaSDK();
                
                // Test aliases exist
                const aliases = ['send', 'sendMessage', 'emit', 'broadcast'];
                for (const alias of aliases) {
                    if (typeof vdo[alias] !== 'function') {
                        throw new Error(`Alias ${alias} not found`);
                    }
                }
                
                console.log('✅ All aliases exist');
                process.exit(0);
            } catch (error) {
                console.error('❌ Alias test failed:', error);
                process.exit(1);
            }
        }
        test();
        EOF
        timeout 30s node test-aliases.js

  test-summary:
    needs: test-sdk
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Check test results
      run: |
        if [ "${{ needs.test-sdk.result }}" == "success" ]; then
          echo "✅ All SDK tests passed!"
          exit 0
        else
          echo "❌ Some SDK tests failed"
          exit 1
        fi
